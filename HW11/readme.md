>развернуть виртуальную машину любым удобным способом  
>поставить на неё PostgreSQL 15 любым способом  

`docker pull postgres:15`  
`docker run --name pg -v c:\var\lib\postgresql\data:/var/lib/postgresql/data -e POSTGRES_PASSWORD=1 -d postgres:15`  
`docker exec -t -i pg bash`  
`apt update`  
`apt install procps systemctl`   

>настроить кластер PostgreSQL 15 на максимальную производительность не обращая внимание на возможные проблемы с надежностью в случае аварийной перезагрузки виртуальной машины
>нагрузить кластер через утилиту через утилиту pgbench (https://postgrespro.ru/docs/postgrespro/14/pgbench)
>написать какого значения tps удалось достичь, показать какие параметры в какие значения устанавливали и почему


`free -h`  
|               |total      |  used    |    free   |   shared | buff/cache |  available|
|---------------|-----------|----------|-----------|----------|------------|-----------|
|Mem:           |969Mi      | 470Mi    |   149Mi   |     15Mi |      349Mi |      342Mi|
|Swap:          |1.0Gi      |  85Mi    |   938Mi   |

`grep processor /proc/cpuinfo -c`  
2

`passwd postgres`  
`login postgres`  

посмотрим на результаты работы утилиты с настройками по умолчанию, чтобы было с чем потом сравнивать  

`psql`  

сохраняю текущие настройки для сравнения

`SELECT * INTO def_param FROM pg_settings;`

`\q`  
`pgbench -i postgres`  
`pgbench -c5 -P 6 -T 60 -U postgres postgres`  

tps = 931.575073  

теперь попробую настройки, которые предлагают на https://pgconfigurator.cybertec.at/  
получились [такие](cybertec.jpg)  
копирую их в postgresql.auto.conf, перезапускаю сервер (контейнер), переинсталлирую таблицы утилиты, тестирую    

`logout`  
`exit`  
`docker restart pg`  
`docker exec -t -i pg bash`  
`login postgres`   
`pgbench -i postgres`  
`pgbench -c5 -P 6 -T 60 -U postgres postgres`  

tps = 757.041301

Стало хуже. Попробую сравнить настройки, которые предлагает Сybertec с настройками по умолчанию. Все настройки от Сybertec у меня в postgresql.auto.conf, а предыдущие — в таблице def_param. Делаю выборку и справниваю. При сравнении пытаюсь разобраться и как-то прокомментировать (сильно не смейтесь=), почему выбираю такие настройки. Пока изучал документацию и делал пробные запуски утилиты, стало очевидно, что многие настройки оказывают тот или иной эффект, когда они настроены в комплексе, а их настройка по отдельности либо не даст ожидаемго эфеекта, либо сделает только хуже. В общем, тут еще изучать и изучать, эксперементировать и практивоваться.  

`SELECT
    COALESCE(ctec.name, def_param.name) name, 
    def_param.setting def_param,  
    ctec.setting ctec
FROM   
    pg_settings ctec  
FULL JOIN   
    def_param  
ON  
    ctec.name=def_param.name AND ctec.sourcefile LIKE '%postgresql.auto.conf%'
WHERE 
      def_param.setting <> ctec.setting OR 
      def_param.name IN ('wal_buffers','autovacuum', 'max_wal_size');`  
    

|name|def_param|ctec|Мои настройки + комментарий| 
|-|-|-|-|
autovacuum|on||оставляю по умолчанию
 bgwriter_flush_after             | 64      | 0                  |не понял, что это, оставляю рекомендуемое 
 checkpoint_timeout               | 300     | 900                |выставляю 100. Тестирование выполняется 60 сек, так что ни одной контрольной точки не успеет выполнится. Если таки наскочу на одну,то пусть это будет хотя бы недолго — checkpoint_completion_targed=0.01. max_wal_size установлю в 2GB, а shared_buffers подниму влотную к максимуму (900MB). Тем самым пытаюсь снизить частоту сброса грязных буферов на диск в эти 60 сек (снизив взаимодействия Postgres с диском, по крайней мере, надеюсь на это)
 effective_cache_size             | 524288  | 131072             |оставляю по умолчанию|
 effective_io_concurrency         | 1       | 100                |1000 — максимум|
 enable_partitionwise_aggregate   | off     | on                 |off — секционированные таблицы утилита не создает|    
 enable_partitionwise_join        | off     | on                 |off — секционированные таблицы утилита не создает|
 huge_pages                       | try     | off|не понял, что такое "огромные страницы", оставлю рекомендуемое 
 maintenance_io_concurrency       | 10      | 100                |оставлю рекомендуемое
 maintenance_work_mem             | 65536   | 327680|скорее всего, во время тестирования никаких операций по обслуживанию БД не успеет выполниться + при запуске утилиты VACUUM не будет выполняться также, так что особого смысла в том, что здесь будет указано, наверное, нет. Но поставлю 900MB| 
 max_connections                  | 100     | 20                 |6 (5 для утилиты + 1 мое), но в данном случае можно и не трогать|    
 max_parallel_maintenance_workers | 2       | 1 |оставляю рекомендуемое  
 max_parallel_workers             | 8       | 2 |оставляю рекомендуемое   
 max_parallel_workers_per_gather  | 2       | 1 |не понял, что это, оставляю рекомендуемое
 max_slot_wal_keep_size           | -1      | 1000|репликации у меня нет, так что пусть останется по умолчанию
 max_wal_senders                  | 10      | 0|репликации мне не нужна, оставлю предлагаемое
 max_wal_size|1024|1024|2GB — в комментари к checkpoint_timeout писал, зачем мне это
 max_worker_processes             | 8       | 2 |у меня 2 процессора, оставляю рекомендуемое
 min_wal_size                     | 80      | 512|2GB — тут ожидаю, что сервер не удалит ни одного WAL-файла за время тестирования. Ну и до их переработки вряд ли дело дойдет. Тем самым что-то сэкономлю на удалении и перезаписи файлов
 random_page_cost                 | 4       | 1.25|у меня SSD, судя по докуменации, лучше оставить рекомендуемое
 shared_buffers                   | 16384   | 32768|рекомендуется 25-40%, выставлю как можно больше (900MB)              
 shared_preload_libraries         |         | pg_stat_statements|'' — отслеживать статистику выполнения сервером SQL-операторов не планирую
 synchronous_commit               | on      | off|комитим транзакции без подтверждения сброса WAL на диск, оставляем рекомендуемое
 track_functions                  | none    | pl|подсчёт вызовов функций и времени их выполнения делать не планирую, во время тестировани они не вызываются, оставляю по умолчанию
 track_io_timing                  | off     | on|замеры времени операций ввода/вывода — тоже, оставляю по умолчанию
 track_wal_io_timing              | off     | on|замеры времени операций ввода/вывода WAL  — тоже, оставляем по умолчанию
 wal_buffers                      | 512     | 2048|оставляю предлагаемое, буферы сбрасываются на диск после каждой фиксации транзакции, а таких здоровых транзакций (чтобы забить 16МБ буфер) утилита не выполняет
 wal_compression                  | off     | pglz|off дает меньшую нагрузку на процессор (а цели сэкономить дисковое пространство у меня нет), оставляю по умолчанию
 wal_recycle                      | on      | off|off — переиспользование более ресурсоемко, чем запись в новый файл, оставляю предлагаемое
 work_mem                         | 4096    | 32768|900MB — объем памяти используемый при обработке запросов для выполнения некоторых операций 

tps = 2765.306083  

